/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package command-line-arguments */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h>

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 37 "nasp.go"

#include <stdlib.h>

struct GoError {
	char *error_msg;
};

inline struct GoError *create_go_error(char *error_msg) {
	struct GoError *p;

	p = malloc(sizeof(struct GoError));
	p->error_msg = error_msg;

	return p;
};

struct GoHTTPHeaderItem {
	char *key;
	char *value;
};

struct GoHTTPHeaders {
	struct GoHTTPHeaderItem *items;
	unsigned int size;
};

struct GoHTTPResponse {
	int status_code;
	char *version;
	struct GoHTTPHeaders headers;
    char *body;
};

inline struct GoHTTPResponse *create_go_http_response(int status_code, char *version, struct GoHTTPHeaders headers, char *body) {
	struct GoHTTPResponse *p;

	p = malloc(sizeof(struct GoHTTPResponse));
	p->status_code = status_code;
	p->version = version;
	p->headers = headers;
	p->body = body;

	return p;
};

inline struct GoHTTPHeaderItem *new_http_headers(unsigned int count) {
	struct GoHTTPHeaderItem *p;

	p = malloc(sizeof(struct GoHTTPHeaderItem) * count);

	return p;
};


inline void set_http_header_at(struct GoHTTPHeaderItem *headers, struct GoHTTPHeaderItem header, unsigned int index) {
	headers[index] = header;
};

inline void free_http_headers(struct GoHTTPHeaderItem *headers, unsigned int size) {
	if(headers == NULL) {
		return;
	}

	for(int i = 0; i < size; i++) {
		free(headers[i].key);
		free(headers[i].value);
	}

	free(headers);
};


#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef size_t GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
#ifdef _MSC_VER
#include <complex.h>
typedef _Fcomplex GoComplex64;
typedef _Dcomplex GoComplex128;
#else
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
#endif

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


/* Return type for NewHTTPTransport */
struct NewHTTPTransport_return {
	unsigned long long r0;
	struct GoError* r1;
};
extern struct NewHTTPTransport_return NewHTTPTransport(char* heimdallURLPtr, char* clientIDPtr, char* clientSecretPtr, _Bool usePushGateWay, char* pushGatewayAddressPtr);

/* Return type for SendHTTPRequest */
struct SendHTTPRequest_return {
	struct GoHTTPResponse* r0;
	struct GoError* r1;
};
extern struct SendHTTPRequest_return SendHTTPRequest(unsigned long long httpTransportID, char* method, char* url, char* body);
extern void CloseHTTPTransport(unsigned long long httpTransportID);
extern void FreeGoError(struct GoError* p);
extern void FreeGoHTTPResponse(struct GoHTTPResponse* p);

#ifdef __cplusplus
}
#endif
