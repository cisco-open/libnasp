// Copyright (c) 2022 Cisco and/or its affiliates. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//       https://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"

	type_any "github.com/golang/protobuf/ptypes/any"
	pstruct "github.com/golang/protobuf/ptypes/struct"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/structpb"
)

var buff = []byte{0x3d, 0x23, 0x4, 0x67, 0x0, 0x0, 0x2, 0x9b, 0xa, 0x2a, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x12, 0xec, 0x4, 0xa, 0x89, 0x4, 0xa, 0x15, 0x78, 0x2d, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x2d, 0x70, 0x65, 0x65, 0x72, 0x2d, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0xef, 0x3, 0x2a, 0xec, 0x3, 0xa, 0x1a, 0xa, 0xe, 0x41, 0x50, 0x50, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x53, 0x12, 0x8, 0x1a, 0x6, 0x61, 0x6c, 0x70, 0x69, 0x6e, 0x65, 0xa, 0x1f, 0xa, 0xa, 0x43, 0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x49, 0x44, 0x12, 0x11, 0x1a, 0xf, 0x77, 0x61, 0x79, 0x6e, 0x7a, 0x30, 0x72, 0x2d, 0x30, 0x36, 0x32, 0x36, 0x2d, 0x30, 0x31, 0xa, 0x19, 0xa, 0xd, 0x49, 0x53, 0x54, 0x49, 0x4f, 0x5f, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e, 0x12, 0x8, 0x1a, 0x6, 0x31, 0x2e, 0x31, 0x31, 0x2e, 0x34, 0xa, 0xe9, 0x1, 0xa, 0x6, 0x4c, 0x41, 0x42, 0x45, 0x4c, 0x53, 0x12, 0xde, 0x1, 0x2a, 0xdb, 0x1, 0xa, 0x27, 0xa, 0xc, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x69, 0x6f, 0x2f, 0x72, 0x65, 0x76, 0x12, 0x17, 0x1a, 0x15, 0x63, 0x70, 0x2d, 0x76, 0x31, 0x31, 0x31, 0x78, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2d, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0xa, 0x24, 0xa, 0x19, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x69, 0x6f, 0x2f, 0x74, 0x6c, 0x73, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x7, 0x1a, 0x5, 0x69, 0x73, 0x74, 0x69, 0x6f, 0xa, 0x30, 0xa, 0x1f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x69, 0x6f, 0x2f, 0x63, 0x61, 0x6e, 0x6f, 0x6e, 0x69, 0x63, 0x61, 0x6c, 0x2d, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0xd, 0x1a, 0xb, 0x61, 0x6c, 0x70, 0x69, 0x6e, 0x65, 0x2d, 0x74, 0x65, 0x73, 0x74, 0xa, 0x2f, 0xa, 0x23, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x69, 0x6f, 0x2f, 0x63, 0x61, 0x6e, 0x6f, 0x6e, 0x69, 0x63, 0x61, 0x6c, 0x2d, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x8, 0x1a, 0x6, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0xa, 0x27, 0xa, 0x19, 0x74, 0x6f, 0x70, 0x6f, 0x6c, 0x6f, 0x67, 0x79, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x69, 0x6f, 0x2f, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0xa, 0x1a, 0x8, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x31, 0xa, 0x12, 0xa, 0x7, 0x4d, 0x45, 0x53, 0x48, 0x5f, 0x49, 0x44, 0x12, 0x7, 0x1a, 0x5, 0x6d, 0x65, 0x73, 0x68, 0x31, 0xa, 0x15, 0xa, 0x4, 0x4e, 0x41, 0x4d, 0x45, 0x12, 0xd, 0x1a, 0xb, 0x61, 0x6c, 0x70, 0x69, 0x6e, 0x65, 0x2d, 0x74, 0x65, 0x73, 0x74, 0xa, 0x16, 0xa, 0x9, 0x4e, 0x41, 0x4d, 0x45, 0x53, 0x50, 0x41, 0x43, 0x45, 0x12, 0x9, 0x1a, 0x7, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0xa, 0x43, 0xa, 0x5, 0x4f, 0x57, 0x4e, 0x45, 0x52, 0x12, 0x3a, 0x1a, 0x38, 0x6b, 0x75, 0x62, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x65, 0x73, 0x3a, 0x2f, 0x2f, 0x61, 0x70, 0x69, 0x73, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x73, 0x2f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x2f, 0x70, 0x6f, 0x64, 0x73, 0x2f, 0x61, 0x6c, 0x70, 0x69, 0x6e, 0x65, 0x2d, 0x74, 0x65, 0x73, 0x74, 0xa, 0x1e, 0xa, 0xd, 0x57, 0x4f, 0x52, 0x4b, 0x4c, 0x4f, 0x41, 0x44, 0x5f, 0x4e, 0x41, 0x4d, 0x45, 0x12, 0xd, 0x1a, 0xb, 0x61, 0x6c, 0x70, 0x69, 0x6e, 0x65, 0x2d, 0x74, 0x65, 0x73, 0x74, 0xa, 0x5e, 0xa, 0x18, 0x78, 0x2d, 0x65, 0x6e, 0x76, 0x6f, 0x79, 0x2d, 0x70, 0x65, 0x65, 0x72, 0x2d, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2d, 0x69, 0x64, 0x12, 0x42, 0x1a, 0x40, 0x73, 0x69, 0x64, 0x65, 0x63, 0x61, 0x72, 0x7e, 0x31, 0x30, 0x2e, 0x32, 0x30, 0x2e, 0x33, 0x2e, 0x31, 0x35, 0x7e, 0x61, 0x6c, 0x70, 0x69, 0x6e, 0x65, 0x2d, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x7e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x2e, 0x73, 0x76, 0x63, 0x2e, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c}

func ParseMetadata(r io.Reader) {
	magicBuf, _ := io.ReadAll(io.LimitReader(r, 4))
	// fmt.Printf("%#v\n", magicBuf)
	magic := binary.BigEndian.Uint32(magicBuf)

	// lengthBuf := buf[4:8]
	lengthBuf, _ := io.ReadAll(io.LimitReader(r, 4))
	// fmt.Printf("%#v\n", lengthBuf)
	length := binary.BigEndian.Uint32(lengthBuf)

	metadataBuf, _ := io.ReadAll(io.LimitReader(r, int64(length)))
	fmt.Printf("HEADER magic[%d] length[%d] datalen[%d]\n", magic, length, len(metadataBuf))
	// metadataBuf := buf[8 : 8+length]
	// fmt.Printf("\n\nMD: (%d) %s\n\n", len(metadataBuf), metadataBuf)

	md2 := &type_any.Any{}
	err := proto.Unmarshal(metadataBuf, md2)
	if err != nil {
		fmt.Printf("%#v\n", metadataBuf)
		fmt.Println(err)
	}

	md := &pstruct.Struct{}
	err = proto.Unmarshal(md2.GetValue(), md)
	if err != nil {
		fmt.Println(err)
	}

	fmt.Printf("%#v\n", md2)
	fmt.Printf("%#v\n\n%#v\n\n\n", getStructValues(md)["x-envoy-peer-metadata-id"], getStructValues(md)["x-envoy-peer-metadata"])
}

func CreateMetadata() []byte {
	lmd := &pstruct.Struct{
		Fields: map[string]*structpb.Value{
			"x-envoy-peer-metadata-id": structpb.NewStringValue("sidecar~10.20.3.15~alpine-test.default~default.svc.cluster.local"),
			"x-envoy-peer-metadata": structpb.NewStructValue(&structpb.Struct{
				Fields: map[string]*structpb.Value{
					"APP_CONTAINERS": structpb.NewStringValue("alpine"),
					"CLUSTER_ID":     structpb.NewStringValue("waynz0r-0626-01"),
					"ISTIO_VERSION":  structpb.NewStringValue("1.11.4"),
					"MESH_ID":        structpb.NewStringValue("mesh1"),
					"NAME":           structpb.NewStringValue("alpine-test"),
					"NAMESPACE":      structpb.NewStringValue("default"),
					"OWNER":          structpb.NewStringValue("kubernetes://apis/v1/namespaces/default/pods/alpine-test"),
					"WORKLOAD_NAME":  structpb.NewStringValue("alpine-test"),
					"LABELS": structpb.NewStructValue(&structpb.Struct{
						Fields: map[string]*structpb.Value{
							"istio.io/rev":                        structpb.NewStringValue("cp-v111x.istio-system"),
							"security.istio.io/tlsMode":           structpb.NewStringValue("istio"),
							"service.istio.io/canonical-name":     structpb.NewStringValue("alpine-test"),
							"service.istio.io/canonical-revision": structpb.NewStringValue("latest"),
							"topology.istio.io/network":           structpb.NewStringValue("network1"),
						},
					}),
				},
			}),
		},
	}

	lmdAny, err := anypb.New(lmd)
	if err != nil {
		fmt.Println(err)
	}

	lmdAnyBytes, err := proto.Marshal(lmdAny)
	if err != nil {
		fmt.Println(err)
	}

	bb := new(bytes.Buffer)
	magic := make([]byte, 4)
	binary.BigEndian.PutUint32(magic, uint32(1025705063))
	bb.Write(magic)
	lb := make([]byte, 4)
	binary.BigEndian.PutUint32(lb, uint32(len(lmdAnyBytes)))
	bb.Write(lb)
	bb.Write(lmdAnyBytes)

	return bb.Bytes()
}

func main() {
	r := bytes.NewReader(buff)
	ParseMetadata(r)
	ParseMetadata(bytes.NewReader(CreateMetadata()))
}

func getStructValues(md *pstruct.Struct) map[string]interface{} {
	attrs := make(map[string]interface{})

	for k, v := range md.GetFields() {
		attrs[k] = getValue(v)
	}

	return attrs
}

func getListValues(v *pstruct.ListValue) []interface{} {
	values := make([]interface{}, 0)
	for _, value := range v.GetValues() {
		values = append(values, getValue(value))
	}

	return values
}

func getValue(v *pstruct.Value) interface{} {
	switch v.Kind.(type) {
	case *pstruct.Value_StructValue:
		return getStructValues(v.GetStructValue())
	case *pstruct.Value_StringValue:
		return v.GetStringValue()
	case *pstruct.Value_BoolValue:
		return v.GetBoolValue()
	case *pstruct.Value_ListValue:
		return getListValues(v.GetListValue())
	case *pstruct.Value_NumberValue:
		return v.GetNumberValue()
	}

	return nil
}
