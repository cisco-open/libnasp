{{ $structName := .Name }}
// Code generated by kafka-protocol-go. DO NOT EDIT.

//  Copyright (c) 2023 Cisco and/or its affiliates. All rights reserved.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//        https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.
package {{ .Package }}

{{ with .Imports }}
import (
{{ range . }}
{{- . }}
{{ end }}
)
{{- end }}




{{- range .Fields }}
var {{ $structName | CamelCase }}{{ .PropertyName }} = fields.Context{
        SpecName:                       {{ .FieldContext.SpecName | quote }},
        {{- if (.FieldContext.SpecTag.IsDefined) }}
        SpecTag:                        fields.Tag({{ (.FieldContext.SpecTag.Get) }}),
        {{- end }}
        {{- if .FieldContext.CustomDefaultValue }}
          {{- if eq .Type "fields.NullableString" }}
          CustomDefaultValue:              {{ .FieldContext.CustomDefaultValue | quote }},
          {{ else }}
          CustomDefaultValue:              {{ .Type }}({{ .FieldContext.CustomDefaultValue }}),
          {{- end }}
        {{- end }}
        LowestSupportedVersion:          {{ .FieldContext.LowestSupportedVersion }},
        HighestSupportedVersion:         {{ .FieldContext.HighestSupportedVersion }},
        {{- if or .FieldContext.LowestSupportedFlexVersion .FieldContext.HighestSupportedFlexVersion }}
        LowestSupportedFlexVersion:      {{ .FieldContext.LowestSupportedFlexVersion }},
        HighestSupportedFlexVersion:     {{ .FieldContext.HighestSupportedFlexVersion }},
        {{- end }}
        {{- if or .FieldContext.LowestSupportedNullableVersion .FieldContext.HighestSupportedNullableVersion }}
        LowestSupportedNullableVersion:  {{ .FieldContext.LowestSupportedNullableVersion }},
        HighestSupportedNullableVersion: {{ .FieldContext.HighestSupportedNullableVersion }},
        {{- end }}
        {{- if and (.FieldContext.SpecTag.IsDefined) (or .FieldContext.LowestSupportedTaggedVersion .FieldContext.HighestSupportedTaggedVersion) }}
        LowestSupportedTaggedVersion:    {{ .FieldContext.LowestSupportedTaggedVersion }},
        HighestSupportedTaggedVersion:   {{ .FieldContext.HighestSupportedTaggedVersion }},
        {{- end }}
    }
{{- end }}

type {{ .Name }} struct {
{{ range .Fields }}
{{- with .Description }}
// {{ . }}
{{- end }}
{{ .Name }} {{ .Type }}
{{- end }}
    unknownTaggedFields []fields.RawTaggedField

    isNil bool
}

{{ range .Fields }}
func (o *{{$structName | printf "%s"}}) {{ .PropertyName }}() {{ .Type }} {
    return o.{{ .Name }}
}

func (o *{{$structName | printf "%s"}}) Set{{ .PropertyName }}(val {{ .Type }}) {
    o.isNil = false
    o.{{ .Name }} = val
}
{{ end }}

{{- if ne .ApiKey -1 }}
func (o *{{$structName | printf "%s"}}) ApiKey() int16 {
    return {{ .ApiKey }}
}
{{- end }}

func (o *{{$structName | printf "%s"}}) UnknownTaggedFields() []fields.RawTaggedField {
    return o.unknownTaggedFields
}

func (o *{{$structName | printf "%s"}}) SetUnknownTaggedFields(val []fields.RawTaggedField) {
    o.unknownTaggedFields = val
}

func (o *{{$structName | printf "%s"}}) Read(buf *bytes.Reader, version int16) error {
    o.SetDefault()
{{ range .Fields }}
    {{ if .IsArrayOfStruct }}
      {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
      if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
      {{- end }}
           {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
           {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }} }
           {{ .Name }}, err :=  {{ .Name }}Field.Read(buf, version);
           if err != nil {
               return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
           }
           o.{{ .Name }} = {{ .Name }}
           {{- end }}
      {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
       } {{- /* IsTaggedVersion check */ -}}
      {{- end }}
    {{ else if .IsArray }}  {{- /* array of primitive types */ -}}
        {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
        if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
        {{- end }}
             {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
             {{ .Name }}Field := {{ .FieldType }}{
                Context: {{ $structName | CamelCase }}{{ .PropertyName }},
                ElementProcessor: &{{ .ArrayElementType }}{Context: {{ $structName | CamelCase }}{{ .PropertyName }}} }

            {{ .Name }}, err :=  {{ .Name }}Field.Read(buf, version);
            if err != nil {
                return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
            }
            o.{{ .Name }} = {{ .Name }}
            {{- end }}
        {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
         } {{- /* IsTaggedVersion check */ -}}
        {{- end }}
	{{ else if .IsStruct }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
            if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
            {{- end }}
                {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsSupportedVersion(version) {
                    if err := o.{{ .Name }}.Read(buf, version); err != nil {
                        return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
                    }
                }
                {{- end }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
             } {{- /* IsTaggedVersion check */ -}}
            {{- end }}
	{{ else }} {{- /* primitive type */ -}}
        {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
        if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
        {{- end }}
            {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
            {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }}}
            if err :=  {{ .Name }}Field.Read(buf, version, &o.{{ .Name }}); err != nil {
                return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
            }
            {{- end }}
        {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
          } {{- /* IsTaggedVersion check */ -}}
        {{- end }}

	{{- end }}
{{- end }}

    // process tagged fields
{{ if or (ne .Constraints.LowestSupportedFlexVersion -1) (ne .Constraints.HighestSupportedFlexVersion -1) }}
    if version < {{ .Name }}LowestSupportedFlexVersion() || version > {{ .Name }}HighestSupportedFlexVersion() {
        // tagged fields are only supported by flexible versions
        o.isNil = false
        return nil
    }
{{- end }}

    if buf.Len() == 0 {
      o.isNil = false
      return nil
    }

    {{ if .Constraints.HasKnownTaggedFields }}
    {{- range .Fields }}
    {{- if (.FieldContext.SpecTag.IsDefined) }}
      {{ if .IsArrayOfStruct }} {{- /* array of struct types */ -}}
        {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }} }
      {{ else if .IsArray }} {{- /* array of primitive types */ -}}
        {{ .Name }}Field := {{ .FieldType }}{
            Context: {{ $structName | CamelCase }}{{ .PropertyName }},
            ElementProcessor: &{{ .ArrayElementType }}{Context: {{ $structName | CamelCase }}{{ .PropertyName }}} }
      {{- else if .IsStruct }}
      {{ else }} {{- /* tagged field of primitive type */ -}}
        {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }}}
      {{- end }}
    {{- end }}
    {{- end }}
    {{- end }}

    rawTaggedFields, err := fields.ReadRawTaggedFields(buf)
    if err != nil {
        return err
    }

    {{ if .Constraints.HasKnownTaggedFields }}
    for i := range rawTaggedFields {
        switch rawTaggedFields[i].Tag() {
        {{- range .Fields }}
        {{- if (.FieldContext.SpecTag.IsDefined) }}
        case {{ (.FieldContext.SpecTag.Get) }}:
            {{- if .IsArrayOfStruct }} {{- /* array of struct types */ -}}
                if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
                  return errors.New(strings.Join([]string{"tagged field \"{{ .Name }}\" is not supported by version", strconv.Itoa(int(version))}, " "))
                }
               {{ .Name }}, err :=  {{ .Name }}Field.Read(bytes.NewReader(rawTaggedFields[i].Value()), version);
               if err != nil {
                   return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
               }
               o.{{ .Name }} = {{ .Name }}
            {{- else if .IsArray }}  {{- /* array of primitive types */ -}}
                if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
                   return errors.New(strings.Join([]string{"tagged field \"{{ .Name }}\" is not supported by version", strconv.Itoa(int(version))}, " "))
                }
                {{ .Name }}, err :=  {{ .Name }}Field.Read(bytes.NewReader(rawTaggedFields[i].Value()), version);
                if err != nil {
                    return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
                }
                o.{{ .Name }} = {{ .Name }}
            {{- else if .IsStruct }}
                if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
                    return errors.New(strings.Join([]string{"tagged field \"{{ .Name }}\" is not supported by version", strconv.Itoa(int(version))}, " "))
                }
                if err := o.{{ .Name }}.Read(bytes.NewReader(rawTaggedFields[i].Value()), version); err != nil {
                    return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
                }
            {{- else }} {{- /* primitive type */ -}}
                if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
                   return errors.New(strings.Join([]string{"tagged field \"{{ .Name }}\" is not supported by version", strconv.Itoa(int(version))}, " "))
                }
                if err :=  {{ .Name }}Field.Read(bytes.NewReader(rawTaggedFields[i].Value()), version, &o.{{ .Name }}); err != nil {
                    return errors.WrapIf(err, "couldn't set \"{{ .Name }}\" field")
                }
            {{- end }}
            rawTaggedFields[i].Release()
        {{- end }}
        {{- end }}
        default:
            o.unknownTaggedFields = append(o.unknownTaggedFields, rawTaggedFields[i])
        }
    }
    {{ else }}
    o.unknownTaggedFields = rawTaggedFields
    {{- end }}

    o.isNil = false
	return nil
}

func (o *{{$structName | printf "%s"}}) Write(buf *typesbytes.SliceWriter, version int16) error {
    if o.IsNil() {
        return nil
    }
    if err := o.validateNonIgnorableFields(version); err != nil {
        return err
    }
    {{ range .Fields }}
        {{ if .IsArrayOfStruct }}
            {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }} }
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
            if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
            {{- end }}
                 {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
                 if err :=  {{ .Name }}Field.Write(buf, version, o.{{ .Name }}); err != nil {
                     return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
                 }
                 {{- end }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
             } {{- /* IsTaggedVersion check */ -}}
            {{- end }}
        {{ else if .IsArray }}  {{- /* array of primitive types */ -}}
            {{ .Name }}Field := {{ .FieldType }}{
                                Context: {{ $structName | CamelCase }}{{ .PropertyName }},
                                ElementProcessor: &{{ .ArrayElementType }}{Context: {{ $structName | CamelCase }}{{ .PropertyName }}} }
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
            if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
            {{- end }}
                {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
                if err :=  {{ .Name }}Field.Write(buf, version, o.{{ .Name }}); err != nil {
                    return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
                }
                {{- end }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
             } {{- /* IsTaggedVersion check */ -}}
            {{- end }}
        {{ else if .IsStruct }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
            if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
            {{- end }}
                {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsSupportedVersion(version) {
                    if err := o.{{ .Name }}.Write(buf, version); err != nil {
                        return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
                    }
                }
                {{- end }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
             } {{- /* IsTaggedVersion check */ -}}
            {{- end }}
        {{ else }} {{- /* primitive type */ -}}
            {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }} }
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
            if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
            {{- end }}
                {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
                    {{- if eq .Type "fields.RecordBatches" }}
                    if err :=  {{ .Name }}Field.Write(buf, version, &o.{{ .Name }}); err != nil {
                    {{- else }}
                    if err :=  {{ .Name }}Field.Write(buf, version, o.{{ .Name }}); err != nil {
                    {{- end }}
                        return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
                }
                {{- end }}
            {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
              } {{- /* IsTaggedVersion check */ -}}
            {{- end }}
        {{- end }}

    {{- end }}

    // serialize tagged fields
    numTaggedFields := o.getTaggedFieldsCount(version)
    {{- if eq .Constraints.LowestSupportedFlexVersion -1 }}
    if numTaggedFields > 0 {
        return errors.New(strings.Join([]string{"tagged fields were set, but version", strconv.Itoa(int(version)), "of this message does not support them"}, " "))
    }
    {{- end }}
    {{- if and (ne .Constraints.LowestSupportedFlexVersion -1) (ne .Constraints.HighestSupportedFlexVersion -1) }}
    if version < {{ .Name }}LowestSupportedFlexVersion() || version > {{ .Name }}HighestSupportedFlexVersion() {
      if numTaggedFields > 0 {
        return errors.New(strings.Join([]string{"tagged fields were set, but version", strconv.Itoa(int(version)), "of this message does not support them"}, " "))
      }

      return nil
    }
    {{ end }}

    rawTaggedFields := make([]fields.RawTaggedField, 0, numTaggedFields)
    rawTaggedFields = append(rawTaggedFields, o.unknownTaggedFields...)
    {{- if .Constraints.HasKnownTaggedFields }}
    var taggedField fields.RawTaggedField

    {{ range .Fields }}
    {{- if (.FieldContext.SpecTag.IsDefined) }}
      {{- if or .IsArrayOfStruct .IsArray }}
      if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && len(o.{{ .Name }}) > 0 {
        size, err := {{ .Name }}Field.SizeInBytes(version, o.{{ .Name }})
        if err != nil {
            return errors.WrapIf(err, "couldn't determine \"{{ .Name }}\" field size in bytes")
        }
        w := typesbytes.NewSliceWriter(make([]byte, 0, size))
        if err := {{ .Name }}Field.Write(&w, version, o.{{ .Name }}); err != nil {
            return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
        }
      {{- else if .IsStruct }}
      {{ .Name }}DefaultValue := {{ .Type }}Default()
      if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.Equal(&{{ .Name }}DefaultValue) {
            size, err := o.{{ .Name }}.SizeInBytes(version)
            if err != nil {
                return errors.WrapIf(err, "couldn't determine \"{{ .Name }}\" field size in bytes")
            }
            w := typesbytes.NewSliceWriter(make([]byte, 0, size))
            if err := o.{{ .Name }}.Write(&w, version); err != nil {
                return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
            }
      {{- else }}
        {{- if .FieldContext.CustomDefaultValue }}
            {{- if eq .Type "fields.NullableString" }}
              {{- if eq .FieldContext.CustomDefaultValue "null" }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsNil() {
              {{- else }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }}.Value() != {{ .FieldContext.CustomDefaultValue | quote }} {
              {{- end }}
            {{- else }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != {{ .FieldContext.CustomDefaultValue }} {
            {{- end }}
        {{- else }}
          {{- if eq .Type "fields.NullableString" }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }}.Value() != "" {
          {{- else if eq .Type "fields.UUID" }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsZero() {
          {{- else if eq .Type "fields.RecordBatches" }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsNil() {
          {{- else if eq .Type "bool" }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} {
          {{- else if eq .Type "[]byte" }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != nil {
          {{- else }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != 0 {
          {{- end }}
        {{- end }}
            {{- if eq .Type "fields.RecordBatches" }}
            size, err := {{ .Name }}Field.SizeInBytes(version, &o.{{ .Name }})
            {{- else }}
            size, err := {{ .Name }}Field.SizeInBytes(version, o.{{ .Name }})
            {{- end }}
            if err != nil {
                return errors.WrapIf(err, "couldn't determine \"{{ .Name }}\" field size in bytes")
            }
            w := typesbytes.NewSliceWriter(make([]byte, 0, size))

            {{- if eq .Type "fields.RecordBatches" }}
            if err := {{ .Name }}Field.Write(&w, version, &o.{{ .Name }}); err != nil {
            {{- else }}
            if err := {{ .Name }}Field.Write(&w, version, o.{{ .Name }}); err != nil {
            {{- end }}
                return errors.WrapIf(err, "couldn't serialize \"{{ .Name }}\" field")
            }
      {{- end }}
        taggedField.SetTag({{ (.FieldContext.SpecTag.Get) }})
        taggedField.SetValue(w.Bytes())
        rawTaggedFields = append(rawTaggedFields, taggedField)
      }
    {{- end }}
    {{- end }}
    {{- end }}

    if err := fields.WriteRawTaggedFields(buf, rawTaggedFields); err != nil {
        return errors.WrapIf(err, "couldn't serialize tagged fields")
    }

    return nil
}

func (o *{{$structName | printf "%s"}}) String() string {
    s, err := o.MarshalJSON()
    if err != nil {
        return err.Error()
    }

    return string(s)
}

func (o *{{$structName | printf "%s"}}) MarshalJSON() ([]byte, error) {
    if o == nil || o.IsNil() {
        return []byte("null"), nil
    }

    s := make([][]byte, 0, {{len .Fields | add1}})
    {{- range .Fields }}
    {{- if .IsArrayOfStruct }}
    if b, err := fields.ArrayOfStructMarshalJSON({{ .Name | quote }}, o.{{ .Name }}); err != nil {
        return nil, err
    } else {
        s = append(s, b)
    }
    {{- else if .IsArray }}
    if b, err := fields.ArrayMarshalJSON({{ .Name | quote }}, o.{{ .Name }}); err != nil {
        return nil, err
    } else {
        s = append(s, b)
    }
    {{- else if .IsStruct }}
    if b, err := o.{{ .Name }}.MarshalJSON(); err != nil {
        return nil, err
    } else {
       s = append(s, bytes.Join([][]byte{[]byte("\"{{ .Name }}\""), b}, []byte(": ")))
    }
    {{- else }}
      {{- if eq .Type "[]byte" }}
      if b, err := fields.BytesMarshalJSON({{ .Name | quote }}, o.{{ .Name }}); err != nil {
          return nil, err
      } else {
          s = append(s, b)
      }
      {{- else if eq .Type "fields.RecordBatches" }}
      if b, err := o.{{ .Name }}.MarshalJSON(); err != nil {
         return nil, err
      } else {
        s = append(s, bytes.Join([][]byte{[]byte("\"{{ .Name }}\""), b}, []byte(": ")))
      }
      {{- else if eq .Type "fields.UUID" }}
      if b, err := fields.BytesMarshalJSON({{ .Name | quote }}, o.{{ .Name }}[:]); err != nil {
        return nil, err
      } else {
         s = append(s, b)
      }
      {{- else }}
      if b, err := fields.MarshalPrimitiveTypeJSON(o.{{ .Name }}); err != nil {
        return nil, err
      } else {
        s = append(s, bytes.Join([][]byte{[]byte("\"{{ .Name }}\""), b}, []byte(": ")))
      }
      {{- end }}
    {{- end }}
    {{- end }}

    if b, err := fields.ArrayOfStructMarshalJSON("unknownTaggedFields", o.unknownTaggedFields); err != nil {
        return nil, err
    } else {
        s = append(s, b)
    }

    var b bytes.Buffer
    if err := b.WriteByte('{'); err != nil {
        return nil, err
    }
    if _, err := b.Write(bytes.Join(s, []byte(", "))); err != nil {
        return nil, err
    }
    if err := b.WriteByte('}'); err != nil {
        return nil, err
    }

    return b.Bytes(), nil
}

func (o *{{$structName | printf "%s"}}) IsNil() bool {
	return o.isNil
}

func (o *{{$structName | printf "%s"}}) Clear() {
	o.Release()
	o.isNil = true

	{{ range .Fields }}
	{{- if or .IsArray .IsArrayOfStruct }}
	o.{{ .Name }} = nil
	{{- else if .IsStruct }}
	o.{{ .Name }}.Clear()
	{{- end }}
	{{- end }}
	o.unknownTaggedFields = nil
}

func (o *{{$structName | printf "%s"}}) SetDefault() {
    for i := range o.unknownTaggedFields {
      o.unknownTaggedFields[i].Release()
    }
    o.unknownTaggedFields = nil
    {{- range .Fields }}
    {{- if .IsArrayOfStruct }}
    for i := range o.{{ .Name }} {
        o.{{ .Name }}[i].Release()
    }
    o.{{ .Name }} = nil
    {{- else if or .IsArray  }}
        {{- if eq .Type "[]fields.NullableString" }}
        for i := range o.{{ .Name }} {
          o.{{ .Name }}[i].Release()
        }
        {{- end }}
        o.{{ .Name }} = nil
    {{- else if .IsStruct }}
        o.{{ .Name }}.SetDefault()
    {{- else }}
       {{- if .FieldContext.CustomDefaultValue }}
         {{- if eq .Type "fields.NullableString" }}
            o.{{ .Name }}.SetValue({{ .FieldContext.CustomDefaultValue | quote }})
         {{- else }}
            o.{{ .Name }} = {{ .FieldContext.CustomDefaultValue }}
         {{- end }}
       {{- else }}
        {{- if eq .Type "[]byte" }}
            if o.{{ .Name }} != nil {
                pools.ReleaseByteSlice(o.{{ .Name }})
            }
            o.{{ .Name }} = nil
        {{- else if eq .Type "bool" }}
           o.{{ .Name }} = false
        {{- else if eq .Type "fields.NullableString" }}
          o.{{ .Name }}.SetValue("")
        {{- else if eq .Type "fields.UUID" }}
          o.{{ .Name }}.SetZero()
        {{- else if eq .Type "fields.RecordBatches" }}
           o.{{ .Name }}.ClearAndComplete()
        {{- else }}
            o.{{ .Name }} = 0
        {{- end }}
      {{- end }}
    {{- end }}
    {{- end }}

    o.isNil = false
}

func (o *{{$structName | printf "%s"}}) Equal(that *{{$structName | printf "%s"}}) bool {
    if !fields.RawTaggedFieldsEqual(o.unknownTaggedFields, that.unknownTaggedFields) {
        return false
    }

    {{ range .Fields }}
    {{- if .IsArrayOfStruct }}
    if len(o.{{ .Name }}) != len(that.{{ .Name }}) {
      return false
    }
    for i := range o.{{ .Name }} {
      if !o.{{ .Name }}[i].Equal(&that.{{ .Name }}[i]) {
        return false
      }
    }
    {{- else if .IsArray }}
      {{- if eq .Type "[]fields.NullableString" }}
      if !fields.NullableStringSliceEqual(o.{{ .Name }}, that.{{ .Name }}) {
        return false
      }
      {{- else }}
      if !fields.PrimitiveTypeSliceEqual(o.{{ .Name }}, that.{{ .Name }}) {
        return false
      }
      {{- end }}
    {{- else if .IsStruct }}
    if !o.{{ .Name }}.Equal(&that.{{ .Name }}) {
       return false
    }
    {{- else }}
        {{- if eq .Type "[]byte" }}
        if !bytes.Equal(o.{{ .Name }}, that.{{ .Name }}) {
          return false
        }
        {{- else if eq .Type "fields.NullableString" }}
        if !o.{{ .Name }}.Equal(&that.{{ .Name }}) {
          return false
        }
        {{- else if eq .Type "fields.UUID" }}
        if o.{{ .Name }} != that.{{ .Name }} {
          return false
        }
        {{- else if eq .Type "fields.RecordBatches" }}
        if !o.{{ .Name }}.Equal(&that.{{ .Name }}) {
          return false
        }
        {{- else }}
        if o.{{ .Name }} != that.{{ .Name }} {
          return false
        }
        {{- end }}
    {{- end }}
    {{- end }}

    return true
}

// SizeInBytes returns the size of this data structure in bytes when it's serialized
func (o *{{$structName | printf "%s"}}) SizeInBytes(version int16) (int, error) {
	if o.IsNil() {
		return 0, nil
	}

	if err := o.validateNonIgnorableFields(version); err != nil {
       return 0, err
    }

	size := 0
	fieldSize := 0
	var err error

	{{ range .Fields }}
	{{ if .IsStruct }}
	    {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
        if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
        {{- end }}
          {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
            fieldSize, err = o.{{ .Name }}.SizeInBytes(version)
            if err != nil {
                return 0, errors.WrapIf(err, "couldn't compute size of \"{{ .Name }}\" field")
            }
            size += fieldSize
          {{- end }}
        {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
         } {{- /* IsTaggedVersion check */ -}}
        {{- end }}
	{{- else }}
	    {{- if and .IsArray (not .IsArrayOfStruct) }}
            {{ .Name }}Field := {{ .FieldType }}{
                Context: {{ $structName | CamelCase }}{{ .PropertyName }},
                ElementProcessor: &{{ .ArrayElementType }}{Context: {{ $structName | CamelCase }}{{ .PropertyName }}} }
        {{- else }}
	        {{ .Name }}Field := {{ .FieldType }}{ Context: {{ $structName | CamelCase }}{{ .PropertyName }} }
	    {{- end }}
	    {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
        if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
        {{- end }}
            {{- if not (.FieldContext.OnlyTaggedVersionsSupported) }}
            {{- if eq .Type "fields.RecordBatches" }}
            fieldSize, err = {{ .Name }}Field.SizeInBytes(version, &o.{{ .Name }})
            {{- else }}
            fieldSize, err = {{ .Name }}Field.SizeInBytes(version, o.{{ .Name }})
            {{- end }}
            if err != nil {
                return 0, errors.WrapIf(err, "couldn't compute size of \"{{ .Name }}\" field")
            }
            size += fieldSize
            {{- end }}
        {{- if and (.FieldContext.SpecTag.IsDefined) (not (.FieldContext.OnlyTaggedVersionsSupported)) }}
         } {{- /* IsTaggedVersion check */ -}}
        {{- end }}
	{{- end }}
	{{ end }}

	// tagged fields
	numTaggedFields := int64(o.getTaggedFieldsCount(version))
	if numTaggedFields > 0xffffffff {
	    return 0, errors.New(strings.Join([]string{"invalid tagged fields count:", strconv.Itoa(int(numTaggedFields))}, " "))
	}
    {{- if eq .Constraints.LowestSupportedFlexVersion -1 }}
    if numTaggedFields > 0 {
        return 0, errors.New(strings.Join([]string{"tagged fields were set, but version", strconv.Itoa(int(version)), "of this message does not support them"}, " "))
    }
    {{- end }}
    {{- if and (ne .Constraints.LowestSupportedFlexVersion -1) (ne .Constraints.HighestSupportedFlexVersion -1) }}
    if version < {{ .Name }}LowestSupportedFlexVersion() || version > {{ .Name }}HighestSupportedFlexVersion() {
      if numTaggedFields > 0 {
        return 0, errors.New(strings.Join([]string{"tagged fields were set, but version", strconv.Itoa(int(version)), "of this message does not support them"}, " "))
      }

      return size, nil
    }
    {{ end }}

    taggedFieldsSize := varint.Uint32Size(uint32(numTaggedFields)) // bytes for serializing the number of tagged fields
    {{- if .Constraints.HasKnownTaggedFields }}
        fieldSize = 0

        {{ range .Fields }}
        {{- if (.FieldContext.SpecTag.IsDefined) }}
          {{- if or .IsArrayOfStruct .IsArray }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && len(o.{{ .Name }}) > 0 {
            fieldSize, err = {{ .Name }}Field.SizeInBytes(version, o.{{ .Name }})
            if err != nil {
                return 0, errors.WrapIf(err, "couldn't compute size of \"{{ .Name }}\" field")
            }
          {{- else if .IsStruct }}
          {{ .Name }}DefaultValue := {{ .Type }}Default()
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.Equal(&{{ .Name }}DefaultValue) {
                fieldSize, err = o.{{ .Name }}.SizeInBytes(version)
                if err != nil {
                    return 0, errors.WrapIf(err, "couldn't compute size of \"{{ .Name }}\" field")
                }
          {{- else }}
            {{- if .FieldContext.CustomDefaultValue }}
                {{- if eq .Type "fields.NullableString" }}
                  {{- if eq .FieldContext.CustomDefaultValue "null" }}
                    if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsNil() {
                  {{- else }}
                    if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }}.Value() != {{ .FieldContext.CustomDefaultValue | quote }} {
                  {{- end }}
                {{- else }}
                    if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != {{ .FieldContext.CustomDefaultValue }} {
                {{- end }}
            {{- else }}
              {{- if eq .Type "fields.NullableString" }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }}.Value() != "" {
              {{- else if eq .Type "fields.UUID" }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsZero() {
              {{- else if eq .Type "fields.RecordBatches" }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsNil() {
              {{- else if eq .Type "bool" }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} {
              {{- else if eq .Type "[]byte" }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != nil {
              {{- else }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != 0 {
              {{- end }}
            {{- end }}
                {{- if eq .Type "fields.RecordBatches" }}
                fieldSize, err = {{ .Name }}Field.SizeInBytes(version, &o.{{ .Name }})
                {{- else }}
                fieldSize, err = {{ .Name }}Field.SizeInBytes(version, o.{{ .Name }})
                {{- end }}
                if err != nil {
                    return 0, errors.WrapIf(err, "couldn't compute size of \"{{ .Name }}\" field")
                }
          {{- end }}
            if int64(fieldSize) > 0xffffffff {
               return 0, errors.New(strings.Join([]string{"invalid \"{{ .Name }}\" tagged field value length:", strconv.Itoa(fieldSize)}, " "))
            }
            fieldSize += varint.Uint32Size(uint32(fieldSize)) // bytes for serializing the length of the "{{ .Name }}" field
            fieldSize += varint.Uint32Size({{ (.FieldContext.SpecTag.Get) }}) // bytes for serializing the tag of the "{{ .Name }}" field
            taggedFieldsSize += fieldSize
          }
    {{- end }}
    {{- end }}
    {{- end }}

    for i := range o.unknownTaggedFields {
        length := len(o.unknownTaggedFields[i].Value())
        if int64(length) > 0xffffffff {
        		return 0, errors.New(strings.Join([]string{"invalid field value length:", strconv.Itoa(length), ", tag:", strconv.Itoa(int(o.unknownTaggedFields[i].Tag()))}, " "))
        }
        taggedFieldsSize += varint.Uint32Size(o.unknownTaggedFields[i].Tag()) // bytes for serializing the tag of the unknown tag
        taggedFieldsSize += varint.Uint32Size(uint32(length)) // bytes for serializing the length of the unknown tagged field
        taggedFieldsSize += length
    }

    size += taggedFieldsSize

	return size, nil
}

// Release releases the dynamically allocated fields of this object by returning then to object pools
func (o *{{$structName | printf "%s"}}) Release()  {
	if o.IsNil() {
		return
	}

	for i := range o.unknownTaggedFields {
       o.unknownTaggedFields[i].Release()
    }
    o.unknownTaggedFields = nil

	{{ range .Fields }}
	{{- if .IsStruct }}
	o.{{ .Name }}.Release()
	{{- else if .IsArrayOfStruct }}
	for i := range o.{{ .Name }} {
	  o.{{ .Name }}[i].Release()
	}
	o.{{ .Name }} = nil
	{{- else if or .IsArray }}
	{{- if eq .Type "[]fields.NullableString" }}
    for i := range o.{{ .Name }} {
      o.{{ .Name }}[i].Release()
    }
    {{- end }}
	o.{{ .Name }} = nil
	{{- else if eq .Type "fields.NullableString" }}
    o.{{ .Name }}.Release()
    {{- else if eq .Type "fields.RecordBatches" }}
    o.{{ .Name }}.Release()
    {{- else if eq .Type "[]byte" }}
    if o.{{ .Name }} != nil {
        pools.ReleaseByteSlice(o.{{ .Name }})
    }
	{{- end }}
	{{- end }}
}

func (o *{{$structName | printf "%s"}}) getTaggedFieldsCount(version int16) int {
    numTaggedFields := len(o.unknownTaggedFields)
    {{- if .Constraints.HasKnownTaggedFields }}
    {{ range .Fields }}
    {{- if (.FieldContext.SpecTag.IsDefined) }}
        {{- if or .IsArrayOfStruct .IsArray }}
         if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && len(o.{{ .Name }}) > 0 {
            numTaggedFields++
         }
        {{- else if .IsStruct }}
          if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) {
            {{ .Name }}DefaultValue := {{ .Type }}Default()
            if !o.{{ .Name }}.Equal(&{{ .Name }}DefaultValue) {
                numTaggedFields++
            }
          }
        {{- else }}
          {{- if .FieldContext.CustomDefaultValue }}
            {{- if eq .Type "fields.NullableString" }}
              {{- if eq .FieldContext.CustomDefaultValue "null" }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsNil() {
              {{- else }}
                if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }}.Value() != {{ .FieldContext.CustomDefaultValue | quote }} {
              {{- end }}
            {{- else }}
              if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != {{ .FieldContext.CustomDefaultValue }} {
            {{- end }}
          {{- else }}
            {{- if eq .Type "fields.NullableString" }}
            if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }}.Value() != "" {
            {{- else if eq .Type "fields.UUID" }}
            if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsZero() {
            {{- else if eq .Type "fields.RecordBatches" }}
            if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && !o.{{ .Name }}.IsNil() {
            {{- else if eq .Type "bool" }}
            if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} {
            {{- else if eq .Type "[]byte" }}
            if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != nil {
            {{- else }}
            if {{ $structName | CamelCase }}{{ .PropertyName }}.IsTaggedVersion(version) && o.{{ .Name }} != 0 {
            {{- end }}
          {{- end }}
            numTaggedFields++
          }
        {{- end }}
    {{- end }}
    {{- end }}
    {{- end }}

    return numTaggedFields
}

// validateNonIgnorableFields throws an error if any non-ignorable field not supported by current version is set to
// non-default value
func (o *{{$structName | printf "%s"}}) validateNonIgnorableFields(version int16) error {
{{- range .Fields }}
{{- if and (not .Ignorable) (gt .FieldContext.LowestSupportedVersion 0) }}
    if !{{ $structName | CamelCase }}{{ .PropertyName }}.IsSupportedVersion(version) {
{{- if or .IsArrayOfStruct .IsArray }}
        if len(o.{{ .Name }}) > 0 {
            return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
        }
{{- else if .IsStruct }}
        {{ .Name }}DefaultValue := {{ .Type }}Default()
        if !o.{{ .Name }}.Equal(&{{ .Name }}DefaultValue) {
              return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
        }
{{- else }}
    {{- if .FieldContext.CustomDefaultValue }}
      {{- if eq .Type "fields.NullableString" }}
        {{- if eq .FieldContext.CustomDefaultValue "null" }}
          if !o.{{ .Name }}.IsNil() {
            return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
          }
        {{- else }}
          if o.{{ .Name }}.Value() != {{ .FieldContext.CustomDefaultValue | quote }} {
            return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
          }
        {{- end }}
      {{- else }}
        if o.{{ .Name }} != {{ .FieldContext.CustomDefaultValue }} {
            return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
        }
      {{- end }}
    {{- else }}
      {{- if eq .Type "fields.NullableString" }}
      if o.{{ .Name }}.Bytes() != nil {
        return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
      }
      {{- else if eq .Type "fields.UUID" }}
      if !o.{{ .Name }}.IsZero() {
        return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
      }
      {{- else if eq .Type "fields.RecordBatches" }}
      if !o.{{ .Name }}.IsNil() {
        return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
      }
      {{- else if eq .Type "bool" }}
      if o.{{ .Name }} {
        return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
      }
      {{- else if eq .Type "[]byte" }}
      if o.{{ .Name }} != nil {
        return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
      }
      {{- else }}
      if o.{{ .Name }} != 0 {
        return errors.New(strings.Join([]string{"attempted to write non-default \"{{ .Name }}\" at version", strconv.Itoa(int(version))}, " "))
      }
      {{- end }}
    {{- end }}
{{- end }}
    }
{{- end }}
{{- end }}
    return nil
}

{{ if ne .Constraints.LowestSupportedVersion -1 }}
func {{ .Name }}LowestSupportedVersion() int16 {
    return {{ .Constraints.LowestSupportedVersion }}
}
{{- end }}

{{ if ne .Constraints.HighestSupportedVersion -1 }}
func {{ .Name }}HighestSupportedVersion() int16 {
    return {{ .Constraints.HighestSupportedVersion }}
}
{{- end }}

{{ if ne .Constraints.LowestSupportedFlexVersion -1 }}
func {{ .Name }}LowestSupportedFlexVersion() int16 {
    return {{ .Constraints.LowestSupportedFlexVersion }}
}
{{- end }}

{{ if ne .Constraints.HighestSupportedFlexVersion -1 }}
func {{ .Name }}HighestSupportedFlexVersion() int16 {
    return {{ .Constraints.HighestSupportedFlexVersion }}
}
{{- end }}

func {{ .Name }}Default() {{ .Name }} {
    var d {{ .Name }}
    d.SetDefault()

    return d
}
